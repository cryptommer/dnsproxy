function string.starts(String, Start)
    return string.sub(String, 1, string.len(Start)) == Start
end

function trim(s)
    return s:match "^%s*(.*%S)" or ""
end

function ReloadCerts(dq)
    infolog("[INFO] [SniDust] Reloading certs...")

    -- prevent the query from going upstream
    dq.dh:setQR(true)

    -- load
    reloadAllCertificates()

    infolog("[INFO] [SniDust] Certs reloaded!")

    -- respond with a local address just in case
    return DNSAction.Spoof, "127.0.0.7"
end

-- read all the domains in a set
function LoadBlocklists(smn, folder)
    f = io.popen('/bin/ls ' .. folder .. '*.lst')
    for file in f:lines() do
        infolog ("[INFO] [SniDust] *** Domain List: ".. file .. "***")
        local f = io.open(file, "r")
        if f ~= nil then
            for domain in io.lines(file) do
                -- trim string
                domain = trim(domain)
                -- check if domain is valid
                if domain ~= nil and string.len(domain) > 0 and not string.starts(domain, "#") then
                    local parseTest = pcall(newDNSName, domain)
                    if parseTest then
                        smn:add(newDNSName(domain))
                        infolog("[INFO] [SniDust] Adding domain " .. domain .. " to list")
                    else
                        warnlog("[WARN] [SniDust] Failed to parse/add domain " .. domain .. " => Skipping")
                    end
                end
            end
            io.close(f)
        else
            errlog("[ERROR] [SniDust] The domain list is missing or inaccessible!")
        end
        infolog ("[INFO] [SniDust] *** End of Domain List ***")
    end
end

function ReloadBlocklist(dq)
    infolog("[INFO] [SniDust] Reloading domain lists...")

    -- prevent the query from going upstream
    dq.dh:setQR(true)

    BlockNode = newSuffixMatchNode()

    -- load
    LoadBlocklists(BlockNode, "/etc/snidust/domains.d/")

    infolog("[INFO] [SniDust] Domain Lists reloaded!")

    -- respond with a local address just in case
    return DNSAction.Spoof, "127.0.0.7"
end

function ReloadACL(dq)
    -- prevent the query from going upstream
    dq.dh:setQR(true)

    infolog("[INFO] [SniDust] *** Reloading ACL... ***")
    os.execute("/bin/bash -c /generateACL.sh && /usr/sbin/nginx -s reload")
    setACLFromFile("/etc/dnsdist/allowedClients.acl")
    infolog("[INFO] [SniDust] *** ACL reload complete! ***")

    -- respond with a local address just in case
    return DNSAction.Spoof, "127.0.0.7"
end

-- Enhanced logging with more fields
local logFile = "/var/log/dnsdist/detailed_requests.log"

function detailedLogRequest(dq)
    if dq.dh:getQR() then
        return false -- Skip responses
    end

    local actionInfo = {
        timestamp = os.date("%Y-%m-%dT%H:%M:%SZ"),
        client_ip = dq.remoteaddr:toString(),
        query_name = dq.qname:toString(),
        query_type = dq.qtype,
        protocol = dq.protocol,
        action = "allowed",
        policy = dq.appliedPolicy or "none",
        reason = "none",
        response_code = dq.dh:getRcode(),
        backend = dq.backend and dq.backend:toString() or "none"
    }

    -- Detect different actions
    if dq.dropped then
        actionInfo.action = "dropped"
        actionInfo.reason = "drop_action"
    elseif dq.tag == "blocked" then
        actionInfo.action = "blocked"
        actionInfo.reason = dq.blockReason or "policy"
    elseif dq.dh:getTC() then
        actionInfo.action = "truncated"
    end

    -- Convert to JSON-like format
    local logEntry = string.format('{"timestamp":"%s","client":"%s","query":"%s","qtype":%d,"protocol":"%s","action":"%s","policy":"%s","reason":"%s","rcode":%d,"backend":"%s"}',
        actionInfo.timestamp,
        actionInfo.client_ip,
        actionInfo.query_name,
        actionInfo.query_type,
        actionInfo.protocol,
        actionInfo.action,
        actionInfo.policy,
        actionInfo.reason,
        actionInfo.response_code,
        actionInfo.backend
    )

    -- Write to file
    local file = io.open(logFile, "a")
    if file then
        file:write(logEntry .. "\n")
        file:close()
    end

    return false
end

BlockNode = newSuffixMatchNode()

infolog("[INFO] [SniDust] *** Loading Domain Lists... ***")
LoadBlocklists(BlockNode, "/etc/snidust/domains.d/")
infolog("[INFO] [SniDust] *** Complete! ***")
